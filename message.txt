/* main.c
   ADC + DMA + FIR Filter + Autocorrelation (CMSIS-DSP)
   Streams raw, filtered, and autocorrelation output over UART
*/

#include <zephyr/kernel.h>
#include <zephyr/drivers/adc.h>
#include <zephyr/drivers/dma.h>
#include <zephyr/sys/printk.h>
#include <stdio.h>
#include <inttypes.h>
#include <stm32f7xx.h>
#include "arm_math.h"

#define ADC_NODE DT_ALIAS(adc0)
static const struct device *adc_dev = DEVICE_DT_GET(ADC_NODE);
#define DMA_NODE DT_NODELABEL(dma2)
static const struct device *dma_dev;

#define BUFFER_SIZE 2048
#define BLOCK_SIZE 32
#define NUM_TAPS 29

/* DMA buffer */
static __aligned(32) int16_t dma_buffer[BUFFER_SIZE];
static volatile size_t samples_captured = 0;
static volatile bool capture_complete = false;

/* FIR filter variables */
static arm_fir_instance_f32 S;
static float32_t firStateF32[BLOCK_SIZE + NUM_TAPS - 1];
static const float32_t firCoeffs32[NUM_TAPS] = {
   -0.001542701791023f, -0.002211477329196f, -0.003286228842980f,
   -0.004426511506817f, -0.004758632425987f, -0.003007677342100f,
    0.002192312768827f,  0.011883096781689f,  0.026376427609808f,
    0.044981526235484f,  0.065962076148098f,  0.086760721686126f,
    0.104456011339501f,  0.116349833956158f,  0.120542445424822f,
    0.116349833956158f,  0.104456011339501f,  0.086760721686126f,
    0.065962076148098f,  0.044981526235484f,  0.026376427609808f,
    0.011883096781689f,  0.002192312768827f, -0.003007677342100f,
   -0.004758632425987f, -0.004426511506817f, -0.003286228842980f,
   -0.002211477329196f, -0.001542701791023f
};
static float32_t blockInF32[BLOCK_SIZE];
static float32_t blockOutF32[BLOCK_SIZE];
static float32_t autocorr_output[2 * BLOCK_SIZE - 1];

/* ================== DMA callback ================== */
static void dma_callback(const struct device *dev, void *user_data,
                        uint32_t channel, int status)
{
    ARG_UNUSED(dev);
    ARG_UNUSED(user_data);
    ARG_UNUSED(channel);

    if (status == 0) {
        samples_captured = BUFFER_SIZE;
        capture_complete = true;
    } else {
        printk("DMA error: %d\n", status);
    }
}

/* ================== DMA setup ================== */
int setup_dma(void)
{
    dma_dev = DEVICE_DT_GET(DMA_NODE);
    if (!device_is_ready(dma_dev)) {
        printk("DMA not ready\n");
        return -1;
    }

    static struct dma_block_config dma_block_cfg = {
        .block_size = sizeof(dma_buffer),
        .source_address = (uint32_t)&ADC1->DR,
        .dest_address = (uint32_t)dma_buffer,
        .dest_addr_adj = DMA_ADDR_ADJ_INCREMENT,
        .source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE,
    };

    static struct dma_config dma_cfg = {
        .dma_slot = 0,
        .channel_direction = PERIPHERAL_TO_MEMORY,
        .complete_callback_en = 1,
        .source_data_size = 2,
        .dest_data_size = 2,
        .source_burst_length = 1,
        .dest_burst_length = 1,
        .dma_callback = dma_callback,
        .block_count = 1,
        .head_block = &dma_block_cfg,
    };

    int ret = dma_config(dma_dev, 0, &dma_cfg);
    if (ret < 0) printk("DMA config failed: %d\n", ret);
    return ret;
}

/* ================== ADC setup ================== */
static void adc_dma_hardware_setup(void)
{
    printk("Configuring ADC...\n");

    ADC1->CR2 &= ~ADC_CR2_ADON;
    k_busy_wait(10);
    ADC1->CR1 = 0;
    ADC1->CR2 = 0;
    ADC1->CR2 |= ADC_CR2_CONT | ADC_CR2_DMA | ADC_CR2_DDS;

    ADC1->SMPR2 &= ~ADC_SMPR2_SMP0_Msk;
    ADC1->SMPR2 |= (0b000 << ADC_SMPR2_SMP0_Pos);

    ADC1->SQR1 = 0;
    ADC1->SQR3 = 0;

    ADC1->CR2 |= ADC_CR2_ADON;
    k_busy_wait(10);
    ADC1->CR2 &= ~ADC_CR2_ADON;
    k_busy_wait(10);
    ADC1->CR2 |= ADC_CR2_ADON;
    k_busy_wait(10);

    printk("ADC ready.\n");
}

/* ================== FIR init ================== */
void fir_init(void)
{
    arm_fir_init_f32(&S, NUM_TAPS, (float32_t *)firCoeffs32, firStateF32, BLOCK_SIZE);
}

/* ================== Sampling control ================== */
void start_sampling(void)
{
    samples_captured = 0;
    capture_complete = false;

    if (dma_start(dma_dev, 0) < 0) {
        printk("DMA start failed\n");
        return;
    }

    ADC1->CR2 |= ADC_CR2_SWSTART;
}

/* ================== Processing ================== */
void process_captured_data(void)
{
    if (samples_captured == 0) return;

    for (size_t idx = 0; idx < samples_captured; idx += BLOCK_SIZE) {
        size_t block = MIN(BLOCK_SIZE, samples_captured - idx);

        for (size_t i = 0; i < block; i++) {
            blockInF32[i] = (float32_t)dma_buffer[idx + i];
        }

        arm_fir_f32(&S, blockInF32, blockOutF32, block);

        /* --- Stream Raw + Filtered --- */
        for (size_t i = 0; i < block; i++) {
            printf("RAW,%d\n", dma_buffer[idx + i]);
            printf("FILT,%.4f\n", blockOutF32[i]);
        }

        /* --- Autocorrelation --- */
        arm_correlate_f32(blockOutF32, block, blockOutF32, block, autocorr_output);

        float32_t R0 = autocorr_output[block - 1];
        if (R0 != 0.0f && !isnan(R0)) {
            for (size_t i = 0; i < 2 * block - 1; i++) {
                autocorr_output[i] /= 1000;
            }
        }

        for (size_t i = 0; i < MIN(64, 2 * block - 1); i++) {
            printf("AUTO,%.4f\n", autocorr_output[i]);
        }
    }

    samples_captured = 0;
    capture_complete = false;
}

/* ================== main ================== */
int main(void)
{
    printk("\n*** ADC + DMA + FIR + Autocorrelation ***\n");

    if (!device_is_ready(adc_dev)) {
        printk("ADC not ready\n");
        return 0;
    }

    struct adc_channel_cfg ch_cfg = {
        .gain = ADC_GAIN_1,
        .reference = ADC_REF_INTERNAL,
        .acquisition_time = ADC_ACQ_TIME(ADC_ACQ_TIME_TICKS, 3),
        .channel_id = 0,
        .differential = 0,
    };
    if (adc_channel_setup(adc_dev, &ch_cfg) != 0) {
        printk("ADC channel setup failed\n");
        return 0;
    }

    setup_dma();
    adc_dma_hardware_setup();
    fir_init();

    while (1) {
        start_sampling();
        while (!capture_complete) {
            k_sleep(K_MSEC(1));
        }
        process_captured_data();
        k_sleep(K_MSEC(200));
    }

    return 0;
}
